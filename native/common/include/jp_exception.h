/*****************************************************************************
   Copyright 2004 Steve MÃ©nard

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   
*****************************************************************************/   
#ifndef _JP_EXCEPTION_H_
#define _J_EXCEPTION_H_

/* There are three types of exceptions that we will be propogating.
 * - JPypeException - exceptions issued by an internal failure.
 * - HostException - exceptions generated by Python. 
 * - JavaException - exceptions generated by Java.
 *
 * We must throw the correct exception so that it can properly be handled
 * when returning back to the native code.
 *
 * If we are returning to python, and it is a 
 * - PythonException, then we assume that a python exception has already been 
 *   placed in the python virtual machine.
 * - JavaException, then we will covert it to a python object with the correct
 *   object type.
 * - JPypeException, then we will convert it to a RuntimeError.
 *
 * If we are returning to java, and it is a
 * - PythonException or JPypeException, then convert to a RuntimeException.
 * - JavaException, they we assume there is already an Java exception queue
 *   in the virtual machine.
 *
 */


// FIXME This is being used to issue JPypeException and JavaException, but it
// likely should just be updated to give better audit info.  The key issue being
// that we are depending the additional information from macro __FILE__, __LINE__
// See if this can be replaced and just create a StackInfo() macro that holds those ugly lines.
#define RAISE(exClass, msg) { throw exClass(msg, "unknown", __FILE__, __LINE__); }
#define RAISEF(exClass, function, msg) { throw exClass(msg, function, __FILE__, __LINE__); }

/**
 * Exception issued by JPype to indicate an internal problem.
 */
class JPypeException
{
public :
	JPypeException(const char* msn, const char* function, const char* file, int line) 
	{
		str << msn << endl;
		from(function, file, line);
	}

	JPypeException(const string& msn, const char* function, const char* file, int line)
	{
		str << msn << endl;
		from(function, file, line);
	}

	JPypeException(const JPypeException& ex)
	{ 
		str << ex.str.str();
	}

	virtual ~JPypeException() {}

	const char* getMsg()
	{
		this->msg = str.str();
		return msg.c_str();
	}

	void from(const char* function, const char* file, int line)
	{
		str << "\tat " << function << "("<< file << ":" << line << ")" << endl;
	}

private :
	std::stringstream str;
	string msg;
};

// FIXME this macro is being used in places in place of proper exception safe container classes.
// All instances of this should be redesigned to remove this pattern.
#define RETHROW_CATCH(cleanup) \
catch(...) \
{ \
	cleanup ; \
	throw; \
} 

/**
 * Exception issued with there was a Python exception issued after a python call.
 */
class HostException
{
public :
	HostException() {}
	virtual ~HostException() {}

	virtual const char* getFile() { return "";}
	virtual int getLine() {return 0;}

	virtual string getMessage() { return ""; }
};

/**
 * Exception issued with there was a Java exception issued after a java call.
 */
class JavaException
{
public :
	JavaException(const char* msg, const char* function, const char* f, int l) : file(f), line(l) {message = msg;}
	JavaException(const JavaException& ex) : file(ex.file), line(ex.line) {message = ex.message;}

	virtual ~JavaException() {}

	const char* file;
	int line;

	string message;
};

#endif
